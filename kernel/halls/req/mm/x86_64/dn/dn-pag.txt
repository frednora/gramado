
 Note on paging.c file. The moment where we map the first chunck of memory.

### Why 2 MB chunks are used
- **Simplicity:** One page directory entry can directly map a 2 MB region, so you don’t need to fill 512 smaller 4 KB entries.  
- **Performance:** Fewer TLB entries are needed, reducing overhead.  
- **Bootstrapping:** Early kernel and init process memory regions are contiguous and predictable, so mapping them in big blocks is straightforward.  

###  What your code is mapping
From your comments in `pagesInitializePaging()`:
- **VA = 0x00000000** → Ring 0 area (kernel low memory).  
- **VA = 0x00200000** → Ring 3 area (user mode base).  
- **VA = 0x30000000** → Kernel image region.  
- **VA = 0x30200000** → Frontbuffer (LFB).  
- **VA = 0x30400000** → Backbuffer.  
- **VA = 0x30600000** → Paged pool.  
- **VA = 0x30800000** → Heap pool.  
- **VA = 0x30A00000, 0x30C00000, 0x30E00000** → Extra heaps (slab allocators). 


Canonical Virtual Address Mapping (from pagesInitializePaging())
Virtual Address (VA) Region Mapped	      Purpose
0x00000000	         Ring 0 area	      Kernel low memory (privileged space).
0x00200000	         Ring 3 area	      User mode base (entry point for user processes).
0x30000000	         Kernel image region  Where the kernel binary and data structures are mapped.
0x30200000	         Frontbuffer          (LFB)	Linear frame buffer for direct screen output.
0x30400000	         Backbuffer	          Off‑screen buffer for double buffering (smooth graphics).
0x30600000	         Paged pool	          Region for pageable kernel allocations.
0x30800000	         Heap pool	          Dynamic kernel allocations (malloc‑like).
0x30A00000	         Extra heap 1	      Used by kernel modules.
0x30C00000	         Extra heap 2	      Slab allocator region.
0x30E00000	         Extra heap 3	      Another slab allocator region.
// ...

Each of those is mapped as a **2 MB block**, identity‑mapped or 
mapped to a fixed PA, so the kernel can immediately access them without 
worrying about fine‑grained paging yet.

=======================================================

Let’s document the **main sequence of memory mapping** driven by  
`__initialize_canonical_kernel_pagetables()`. 
This function is the *orchestrator* that calls a set of worker routines, 
each responsible for mapping one canonical region of memory.  

Here’s the breakdown:

---

###  Function: `__initialize_canonical_kernel_pagetables()`
**Purpose:**  
Sets up the kernel’s initial paging structures by mapping 
all the critical static regions (kernel, user, buffers, heaps, pools). 
This is the backbone of your memory manager — 
it ensures the kernel and init process have their required memory mapped 
before demand paging kicks in.

---

###  Workers called by this function

- **`__initialize_ring0area()`**  
  Maps the **Ring 0 area** (kernel low memory). 
  Provides the kernel with direct access to privileged memory space.

- **`__initialize_ring3area()`**  
  Maps the **Ring 3 area** (user mode base). 
  Prepares the virtual memory space where user processes will run.

- **`__initialize_kernelimage_region()`**  
  Maps the **kernel image region**. 
  Ensures the kernel binary and its data structures are accessible in virtual memory.

- **`__initialize_frontbuffer()`**  
  Maps the **frontbuffer (LFB)**. 
  This is the linear frame buffer used for direct screen output.

- **`__initialize_backbuffer()`**  
  Maps the **backbuffer**. 
  Provides off‑screen drawing space for double buffering, reducing flicker.

- **`__initialize_pagedpool()`**  
  Maps the **paged pool** region. 
  This is where pageable kernel allocations will live.

- **`__initialize_heappool()`**  
  Maps the **heap pool**. 
  Provides memory for dynamic kernel allocations (malloc‑like behavior).

- **`__initialize_extraheap1()`**  
  Maps **Extra Heap 1**. Used by kernel modules.

- **`__initialize_extraheap2()`**  
  Maps **Extra Heap 2**. Used by the slab allocator.

- **`__initialize_extraheap3()`**  
  Maps **Extra Heap 3**. Another slab allocator region.

---

###  Sequence Summary
So the flow inside `__initialize_canonical_kernel_pagetables()` looks like:

1. Map **Ring 0 area**         → kernel privileged space.  
2. Map **Ring 3 area**         → user base.  
3. Map **Kernel image region** → kernel binary.  
4. Map **Frontbuffer**         → screen output.  
5. Map **Backbuffer**          → double buffering.  
6. Map **Paged pool**          → pageable kernel memory.  
7. Map **Heap pool**           → dynamic kernel allocations.  
8. Map **Extra heaps (1–3)**   → specialized allocators.  

---

###  Documentation Note
This sequence is the **canonical memory map** for your kernel. 
It defines the static 2 MB chunks that are always present. 
Later, your demand paging system (using frames from 128–256 MB) will extend 
this with dynamic mappings, but this initialization is the foundation.

---

Fred, would you like me to **draw a text‑based diagram** showing the virtual addresses (like `0x30000000`, `0x30200000`, etc.) alongside each worker function? That would make the mapping sequence visually clear in your documentation.