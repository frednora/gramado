/*
 * File: apic.c
 * Document created by Fred Nora - (2023)
 * Credits:
 * Some parts was ported from Sirius-x86-64, created by Nelson Cole.
 *
 *    APIC - Advanced Programmable Interrupt Controller.
 *    Controlador APIC.
 *    APIC ("Advanced Programmable Interrupt Controller") 
 *    is the updated Intel standard for the older PIC.
 *   The APIC is used for 
 *   + sophisticated interrupt redirection, and for 
 *   + sending interrupts between processors.
 *   Stuff:
 *       +Discrete APIC.
 *       +Integrated local APICs.
 *       +APIC timer.
 *       +I/O APICs.
 * Credits:
 *     https://wiki.osdev.org/Symmetric_Multiprocessing
 *     Nelson Cole. (Sirius-x86-64).
 * History:
 *     2015 - Created by Fred Nora.
 *     2023 - Implementing/Porting more basic routines.
 */
// See:
// https://wiki.osdev.org/APIC
// https://wiki.osdev.org/Symmetric_Multiprocessing
// https://www.cheesecake.org/sac/smp.html


// credits: MP Specification.
// APIC has three interrupt modes.
// 1. PIC Mode — 
// effectively bypasses all APIC components and 
// forces the system to operate in single-processor mode.
// 2. Virtual Wire Mode — 
// uses an APIC as a virtual wire, 
// but otherwise operates the same as PIC Mode.
// 3. Symmetric I/O Mode — 
// enables the system to operate with more than one processor.
// Interrupt mode configuration register (IMCR). 
// This register controls whether the interrupt signals 
// that reach the BSP come from the master PIC or 
// from the local APIC.
// In this mode, I/O interrupts are generated by the I/O APIC. 
// All 8259 interrupt lines are either masked or 
// work together with the I/O APIC in a mixed mode.
// Before entering Symmetric I/O Mode, 
// either the BIOS or the operating system 
// must switch out of PIC Mode by changing the IMCR.
// In general, the operating system must use 
// the STARTUP IPI to wake up application processors in
// systems with integrated APICs, 
// but must use INIT IPI in systems with the 82489DX APIC.
// When the system is operated in Symmetric I/O Mode, 
// the operating system may enable the
// LINTIN0 and LINTIN1 of any or all local APICs as necessary.

#include <kernel.h>

// Initialization control.
struct lapic_info_d  LAPIC;

#define APIC_CONFIG_DATA_LVT(TimerMode,Mask,TriggerMode,Remote,InterruptInput,DeliveryMode,Vector)(\
(((unsigned int)(TimerMode) & 0x3 )      << 17) |\
(((unsigned int)(Mask) & 0x1 )           << 16) |\
(((unsigned int)(TriggerMode) & 0x1 )    << 15) |\
(((unsigned int)(Remote) & 0x1 )         << 14) |\
(((unsigned int)(InterruptInput) & 0x1 ) << 13) |\
(((unsigned int)(DeliveryMode) & 0x7 )   << 8)  |\
((unsigned int)(Vector) & 0xff )\
)

unsigned int localId=0;

#define APIC_NULL  0

//
// == private functions: prototypes =====================
//

static unsigned int local_apic_read_command(unsigned short addr);
static void local_apic_write_command(unsigned short addr,unsigned int val);

static unsigned int local_apic_get_id(void);
static unsigned int local_apic_get_version(void);
static void local_apic_eoi(void);

// apic stuffs for x86.
static inline void imcr_pic_to_apic (void);
static inline void imcr_apic_to_pic (void);

static void __apic_disable_legacy_pic(void);

// =====================

/* Flush caches */
/*
void flush_cashes(void)
{
	__asm__("wbinvd");
}
*/


// #todo: 
// Definir porta 70h usada nesse arquivo. ??
static unsigned int local_apic_read_command(unsigned short addr)
{
    if( (void *) LAPIC.lapic_va == NULL ){
        panic("local_apic_read_command: LAPIC.lapic_va\n");
    }

    return *( (volatile unsigned int *)(LAPIC.lapic_va + addr));
}

static void local_apic_write_command(unsigned short addr,unsigned int val)
{
    if( (void *) LAPIC.lapic_va == NULL ){
        panic("local_apic_write_command: LAPIC.lapic_va\n");
    }

    *( (volatile unsigned int *)(LAPIC.lapic_va + addr)) = val;
}

// Get local apic id.
// see: https://wiki.osdev.org/APIC#Local_APIC_registers
// bits 24~31 for pentium 4 and later.
static unsigned int local_apic_get_id(void)
{
    return (unsigned int) (local_apic_read_command(LAPIC_APIC_ID) >> 24) & 0xFF;
}

// Get local apic version.
// see: https://wiki.osdev.org/APIC#Local_APIC_registers
// bits: 0~7 for Integrated APIC.
// 10H~15H
static unsigned int local_apic_get_version(void)
{
    return (unsigned int) (local_apic_read_command(LAPIC_APIC_VERSION) & 0xFF);
}


// EOI Register:
// Write to the register with offset 0xB0 using the value 0 
// to signal an end of interrupt. 
// A non-zero value may cause a general protection fault.
static void local_apic_eoi(void)
{
    local_apic_write_command( (unsigned short) LAPIC_EOI, (unsigned int) 0 );
}

// Spurious Interrupt Vector Register
// Set the Spurious Interrupt Vector Register bit 8 to 
// start receiving interrupts.
// The offset is 0xF0. 
// The low byte contains the number of the spurious interrupt. 
// As noted above, you should probably set this to 0xFF. 
// To enable the APIC, set bit 8 (or 0x100) of this register. 
// If bit 12 is set then EOI messages will not be broadcast. 
// All the other bits are currently reserved.

/*
static void local_apic_set_spurious_interrupt(void);
static void local_apic_set_spurious_interrupt(void)
{
    // #todo:
    // write_reg(0xF0, ReadRegister(0xF0) | 0x100);
}
*/

// =========


/*
 * imcr_pic_to_apic:
 * Handle interrupt mode configuration register (IMCR).
 * This register controls whether the interrupt signals that reach 
 * the BSP come from the master PIC or from the local APIC. 
 * Before entering Symmetric I/O Mode, either the BIOS or 
 * the operating system must switch out of PIC Mode by changing the IMCR.
 */

/*
The IMCR is supported by two read/writable or write-only I/O ports, 22h and 23h, which receive
address and data respectively. To access the IMCR, write a value of 70h to I/O port 22h, which
selects the IMCR. Then write the data to I/O port 23h. The power-on default value is zero, which
connects the NMI and 8259 INTR lines directly to the BSP. Writing a value of 01h forces the
NMI and 8259 INTR signals to pass through the APIC.
The IMCRP bit of the MP feature
information bytes enables the operating system to detect whether the IMCR is
implemented.
*/

static inline void imcr_pic_to_apic (void)
{
// Select IMCR register.
// First, write the value `70h` to port `22h`. 
// This action selects the IMCR for configuration.
    out8 ((unsigned short)0x22, (unsigned char) 0x70);

// NMI and 8259 INTR go through APIC.
// Next, write the desired data value to port `23h`. 
// This data defines the configuration.
// 0x01 - Route to APIC.
    out8 ((unsigned short)0x23, (unsigned char) 0x01);
}

static inline void imcr_apic_to_pic (void)
{
// Select IMCR register.
// First, write the value `70h` to port `22h`. 
// This action selects the IMCR for configuration.
    out8 ((unsigned short)0x22, (unsigned char) 0x70);

// NMI and 8259 INTR go directly to BSP.
// Next, write the desired data value to port `23h`. 
// This data defines the configuration.
// 0x01 - Do NOT route to APIC.
    out8 ((unsigned short)0x23, (unsigned char) 0x00);
}

/*
 creadits: MP Specification
Cache flushing—The processor can generate special flush and 
write-back bus cycles that must be used by external caches 
in a manner that maintains cache coherency. 
The actual responses are implementation-specific and 
may vary from design to design. 
A program can initiate hardware cache flushing by executing a 
WBINVD instruction. This instruction is only guaranteed 
to flush the caches of the local processor.
*/

/*
inline void invalidate_cache_flush(void);
inline void invalidate_cache_flush(void)
{
    asm ("wbinvd");
}
*/

// =================

// #bugbug
// This routine used a lot of hardcoded addresses.
// PAGETABLE_RES5, LAPIC_VA, PD_ENTRY_LAPIC, KERNEL_PD_PA.
int lapic_initializing(unsigned long lapic_pa)
{
// >> Called in x64smp.c
// Setup BSP's local APIC.

    printk("lapic_initializing: \n");

    LAPIC.initialized = FALSE;

// Invalid address.
// 0xFEE00000
// see: x64gpa.h
    if (lapic_pa != __LAPIC_PA)
    {
        LAPIC.initialized = FALSE;
        //panic("lapic_initializing: lapic_pa\n");
        printk("lapic_initializing: lapic_pa\n");
        goto fail;
    }

// #todo
// Do we have apic support in this processor?
    //if (has_apic() != TRUE)
        //panic("lapic_initializing: APIC not supported\n");

// ===================
// Mapping

// page table
// Isso serve pra pegarmos um endereço físico
// que servira de base para criarmos uma pagetable.
// Mas endereço físico e virtual são iguais nessa região.
// Identidade 1:1.
    unsigned long *pt_lapic = (unsigned long *) get_table_pointer_va();

// -------------
// pa
    LAPIC.lapic_pa = (unsigned long) (lapic_pa & 0xFFFFFFFF);
// -------------
// va
// see: x64gva.h
    LAPIC.lapic_va = (unsigned long) LAPIC_VA;

// -------------------------------------
// Mapping area for registers.

    int map_status = -1;
    map_status = (int) mm_map_2mb_region( LAPIC.lapic_pa, LAPIC.lapic_va );
    if (map_status != 0)
        panic("lapic_initializing: on mm_map_2mb_region()\n");

//==========================================

// flush tlb
// #bugbug
// Maybe we need to call a method for that.

    asm ("movq %cr3, %rax");
    asm ("movq %rax, %cr3");

//=====================================

// Let's get some information about the BSP LAPIC.

// Check values into the registers:
// see: 
// https://wiki.osdev.org/APIC#Local_APIC_registers

// ---------------
// ID
    int localid = (int) local_apic_get_id();
    LAPIC.local_id = (int) (localid & 0xFF);
    //printk("localid: %d\n",LAPIC.local_id);

// ---------------
// Version
// 8bits
// 10H~15H
    int localversion = (int) local_apic_get_version();
    LAPIC.local_version = (int) (localversion & 0xFF);
    //printk("localversion: %xH\n", LAPIC.local_version);

//=====================================
// Destination Format Register (DFR)
// Value after reset, flat mode
// depois de invalidar o pic?
    //*(volatile unsigned int*)(LAPIC.lapic_va + ?) = 0xFFFFFFFF; 
// Logical Destination Register (LDR)
// All cpus use logical id 1
    //*(volatile unsigned int*)(LAPIC.lapic_va + ?) = 0x01000000; 
    //*(volatile unsigned int*)(LAPIC.lapic_va + 0x20) = 8;

// Print:
    printk("ID: %d | VERSION: %xH\n",
        LAPIC.local_id,
        LAPIC.local_version );

    // #hackhack
    // This is just a test for now.
    LAPIC.initialized = TRUE;

    return TRUE;
fail:
    //LAPIC.initialized = FALSE;
    return FALSE;
}

//
// ======================================================
//

// #todo
// Testando um código encontrado em https://wiki.osdev.org/APIC.
// setting up the APIC:
 
/* 
 * has_apic:
 *     returns a 'true' value if the CPU supports APIC
 *  and if the local APIC hasn't been disabled in MSRs
 *  note that this requires CPUID to be supported.
 */
// #todo: Change function name.
// See: cpuid.h
int has_apic (void)
{
    int hasAPIC = FALSE;
    unsigned int eax=0;
    unsigned int ebx=0;
    unsigned int ecx=0;
    unsigned int edx=0;

// #bugbug
// Do we have cpuid support?
    cpuid( 1, eax, ebx, ecx, edx );
    hasAPIC = (int) (edx & CPUID_FEAT_EDX_APIC);

    return (int) hasAPIC;
}

// Set the physical address for local APIC registers.
// Is it possible to change the base?
// But we have a default adddress, it is 0xFEE00000.
// Enable APIC by setting up the bit 11.
void cpu_set_apic_base(unsigned long apic) 
{
   unsigned int edx=0;

// Enable APIC by setting up the bit 11.
   unsigned int eax = 
       (unsigned int) (apic & 0xfffff000) | IA32_APIC_BASE_MSR_ENABLE;

//#ifdef __PHYSICAL_MEMORY_EXTENSION__
//   edx = (apic >> 32) & 0x0f;
//#endif
 
    cpuSetMSR (
        (unsigned int) IA32_APIC_BASE_MSR, 
        (unsigned int) eax, 
        (unsigned int) edx );
}
 
/*
 * Get the physical address of the APIC registers page
 * make sure you map it to virtual memory ;)
 */
unsigned long cpu_get_apic_base(void) 
{
    unsigned long APIC_base_address = 0;
    unsigned int eax=0;
    unsigned int edx=0;

    cpuGetMSR(
        (unsigned int) IA32_APIC_BASE_MSR, 
        (unsigned int) &eax, 
        (unsigned int) &edx );

/* 
#ifdef __PHYSICAL_MEMORY_EXTENSION__
   return (eax & 0xfffff000) | ((edx & 0x0f) << 32);
#else
   return (eax & 0xfffff000);
#endif
*/

    APIC_base_address =  (unsigned long) (eax & 0xfffff000);

    return (unsigned long) APIC_base_address;
}

// #todo: 
// #danger !!!
/* Section 11.4.1 of 3rd volume of Intel SDM recommends 
  mapping the base address page as strong uncacheable 
  for correct APIC operation. */
void enable_apic(void)
{
// Called by I_kmain() in main.c.

// #todo
// We need to setup a lot of registers 
// before enabling the apic.

    printk("enable_apic:\n");

// #todo
// Do we have apic support in this processor?
    //if (has_apic() != TRUE)
        //panic("enable_apic: APIC not supported\n");

    if (LAPIC.initialized != TRUE)
        panic("enable_apic: LAPIC not initialized\n");

// Hardware enable the Local APIC if it wasn't enabled.
// Went to the end of this routine.
    //cpu_set_apic_base( cpu_get_apic_base() );

//
// Disable legacy PIC
//

    __apic_disable_legacy_pic();


// Destination Format Register (DFR)
// LAPIC_DFR
// Logical Destination Mode
    // Flat mode
    local_apic_write_command(
        (unsigned short) 0x00e0, 
        (unsigned int) 0xffffffff);


// Logical Destination Register (LDR)
// LAPIC_LDR
// All cpus use logical id 1. ?
    local_apic_write_command(
        (unsigned short) 0x00d0, 
        (unsigned int) 0x01000000);


    localId = local_apic_get_id();

// -- Interrupts ----------------------------------------------------

// Task Priority Register (TPR), to inhibit softint delivery?
// Clear task priority to enable all interrupts.
// Task Priority Register (TPR):
// Clearing TPR to 0 is correct to allow all interrupts. 
// Avoid redundant writes; use your local_apic_write_command wrapper consistently.

    // Allow all interrupts by priority (TPR = 0)
    // Task Priority Register (TPR), to inhibit softint delivery
    // The low 8 bits (0–7) hold the priority threshold.
    local_apic_write_command(
        (unsigned short) LAPIC_TASK_PRIORITY, 
        (unsigned int) 0 );

//---------------------
//#test
//#todo

//
// LVT
//

// What is the Local Vector Table (LVT)?
// The Local Vector Table is a set of registers inside 
// each Local APIC (one per CPU core).
// Each entry in the LVT controls how a particular 
// local interrupt source is delivered to the processor.
// Think of it as a mini routing table for internal LAPIC events,
// separate from the I/O APIC redirection table 
// (which handles external device IRQs).

/*
How many LVT entries exist?
On a typical x86 LAPIC (xAPIC mode), you’ll find about 6–7 LVT registers:
LVT Timer → for the LAPIC’s internal timer
LVT Thermal Sensor → for thermal events (on CPUs that support it)
LVT Performance Counter → for performance monitoring interrupts
LVT LINT0 → local interrupt line 0 (often legacy ExtINT input)
LVT LINT1 → local interrupt line 1 (often NMI input)
LVT Error → for LAPIC internal error reporting
(Sometimes extra): LVT for “CMCI” (Corrected Machine Check Interrupt) on newer CPUs
*/

/*
Quick notes
Mask bit: 
  1 disables the source; 0 enables. 
  Your current setup keeps all LVT sources masked until your IDT and 
  handlers are ready.
Delivery modes:
  0 = Fixed (normal handler at given vector).
  4 = NMI (vector field ignored; delivers NMI).
  7 = ExtINT (bridges legacy PIC external interrupt into LAPIC via LINT0).

When you’re ready:
  Unmask the LAPIC timer (set Mask=0) after setting divide and initial count, 
  and ensure an IDT handler exists at 0x20.
  Decide whether LINT0 should remain masked (typical with IOAPIC routing).
  Unmask LINT1 for NMIs if desired.

Keep vectors collision-free with your IOAPIC mappings and other local sources.
*/

//LVT Timer (vector 0x20):  Masked → no timer interrupts yet.
//LVT Perf Counter (0x21):  Masked → no perf events.
//LVT LINT0 (0x22, ExtINT): Masked → not accepting legacy external interrupts.
//LVT LINT1 (0x23, NMI):    Masked → not accepting NMIs.
//LVT Error (0x24):         Masked → no LAPIC error interrupts.

// Timer interrupt vector, 
// to disable timer interrupts
    //*(volatile unsigned int*)(LAPIC.lapic_va + LAPIC_LVT_TIMER) = 
       // APIC_CONFIG_DATA_LVT(0,1,0,0,0,APIC_NULL,0x20);

/*
LVT TIMER (offset LAPIC_LVT_TIMER)
- Vector:        0x20 (IDT entry to invoke when LAPIC timer fires)
- DeliveryMode:  0 (Fixed)
- Mask:          1 (disabled)  --> Timer won't generate interrupts yet
- TriggerMode:   0 (edge; only relevant for LINT lines; timer ignores)
- Remote:        0 (remote IRR; not used by timer)
- Polarity:      0 (active high; N/A to timer)
- TimerMode:     0 (one-shot; you’ll set divide/initial count later)
*/
    local_apic_write_command(
        (unsigned short) LAPIC_LVT_TIMER,
        (unsigned int) APIC_CONFIG_DATA_LVT(
            /*TimerMode*/      0,
            /*Mask*/           1,
            /*TriggerMode*/    0,
            /*Remote*/         0,
            /*InterruptInput*/ 0,
            /*DeliveryMode*/   0,
            /*Vector*/         LVT_TIMER_VECTOR
        )
    );




// Performance counter interrupt, 
// to disable performance counter interrupts
    //*(volatile unsigned int*)(LAPIC.lapic_va + LAPIC_LVT_PERF) = 
        //APIC_CONFIG_DATA_LVT(APIC_NULL,1,0,0,0,0,0x21);

/*
LVT PERFORMANCE COUNTER (offset LAPIC_LVT_PERF)
- Vector:        0x21
- DeliveryMode:  0 (Fixed)
- Mask:          1 (disabled)
- TriggerMode:   0 (edge; N/A)
- Remote:        0
- Polarity:      0
*/
    local_apic_write_command(
        (unsigned short) LAPIC_LVT_PERF,
        (unsigned int) APIC_CONFIG_DATA_LVT(
            /*TimerMode*/      0,
            /*Mask*/           1,
            /*TriggerMode*/    0,
            /*Remote*/         0,
            /*InterruptInput*/ 0,
            /*DeliveryMode*/   0,
            /*Vector*/         LVT_PERF_VECTOR
        )
    );


// Local interrupt 0, 
// to enable normal external interrupts, Trigger Mode = Level
    //*(volatile unsigned int*)(LAPIC.lapic_va + LAPIC_LVT_LINT0) = 
        //APIC_CONFIG_DATA_LVT(APIC_NULL,1,APIC_NULL,APIC_NULL,1,7,0x22);

/*
LVT LINT0 (offset LAPIC_LVT_LINT0)
- Vector:        0x22
- DeliveryMode:  7 (ExtINT; legacy external interrupt input)
- Mask:          1 (disabled)  --> Not accepting external interrupts via LINT0 now
- TriggerMode:   1 (level)
- Remote:        0 (remote IRR clear)
- Polarity:      1 (active low)  --> common for legacy ISA lines
Note: In symmetric I/O mode with IOAPIC, many kernels keep LINT0 masked and route
external device IRQs via IOAPIC redirection entries instead.
*/
    local_apic_write_command(
        (unsigned short) LAPIC_LVT_LINT0,
        (unsigned int) APIC_CONFIG_DATA_LVT(
            /*TimerMode*/      0,
            /*Mask*/           1,
            /*TriggerMode*/    1,
            /*Remote*/         0,
            /*InterruptInput*/ 1,
            /*DeliveryMode*/   7,
            /*Vector*/         LVT_LINT0_VECTOR
        )
   );



// Local interrupt 1, 
// to enable normal NMI processing
    //*(volatile unsigned int*)(LAPIC.lapic_va + LAPIC_LVT_LINT1) = 
        //APIC_CONFIG_DATA_LVT(APIC_NULL,1,APIC_NULL,APIC_NULL,0,4,0x23);

/*
LVT LINT1 (offset LAPIC_LVT_LINT1)
- Vector:        0x23 (ignored for NMI delivery; NMI doesn’t use the vector field)
- DeliveryMode:  4 (NMI)
- Mask:          1 (disabled)  --> Not accepting NMIs now
- TriggerMode:   0 (edge)
- Remote:        0
- Polarity:      0 (active high)
Note: Typically you’d unmask LINT1 for NMI if you plan to handle NMIs.
*/
    local_apic_write_command(
        (unsigned short) LAPIC_LVT_LINT1,
        (unsigned int) APIC_CONFIG_DATA_LVT(
            /*TimerMode*/      0,
            /*Mask*/           1,
            /*TriggerMode*/    0,
            /*Remote*/         0,
            /*InterruptInput*/ 0,
            /*DeliveryMode*/   4,
            /*Vector*/         LVT_LINT1_VECTOR
        )
    );


// Error interrupt, 
// to disable error interrupts
    //*(volatile unsigned int*)(LAPIC.lapic_va + LAPIC_LVT_ERR) = 
        //APIC_CONFIG_DATA_LVT(APIC_NULL,1,APIC_NULL,APIC_NULL,APIC_NULL,0,0x24);

/*
LVT ERROR (offset LAPIC_LVT_ERR)
- Vector:        0x24
- DeliveryMode:  0 (Fixed)
- Mask:          1 (disabled)  --> No LAPIC error interrupts yet
- TriggerMode:   0 (edge; N/A)
- Remote:        0
- Polarity:      0
Note: Common to keep masked until you install an error handler; then unmask.
*/
    local_apic_write_command(
        (unsigned short) LAPIC_LVT_ERR,
        (unsigned int) APIC_CONFIG_DATA_LVT(
            /*TimerMode*/      0,
            /*Mask*/           1,
            /*TriggerMode*/    0,
            /*Remote*/         0,
            /*InterruptInput*/ 0,
            /*DeliveryMode*/   0,
            /*Vector*/         LVT_ERROR_VECTOR
        )
    );


/*
Spurious-Interrupt Vector Register:
The Spurious-Interrupt Vector Register contains 
 + the bit to enable and disable the local APIC. It also has 
 + a field to specify the interrupt vector number to be delivered 
   to the processor in the event of a spurious interrupt. 
This register is 32 bits and has the following format:

... | 9  | 8  | (  7~4  | 3 | 2 | 1 | 0) 
... | FC | EN | (VECTOR | 1 | 1 | 1 | 1)

EN bit (8):
This allows software to enable or disable the APIC module at any time. 
Writing a value of 1 to this bit enables the APIC module, and 
writing a value of 0 disables it.

VECTOR(7~4):
Bits 4-7 of this field are programmable by software.
This field of the Spurious-Interrupt Vector Register 
specifies which interrupt vector is delivered to the processor 
in the event of a spurious interrupt. 
The processor then transfers control to the 
interrupt handler in the IDT, 
at the vector number delivered to it by the APIC. 
Basically, the VECTOR field specifies 
which interrupt handler to transfer control 
to in the event of a spurious interrupt.
VECTOR(0~3)
Bits 0-3 of this vector field are hard-wired to 1111b, or 15. 

So:
   0x1FF:
   1 ((1111) 1111).
   We are setting the bits 4~7 of the vector
   Interrupt 256 i guess.
*/

// LAPIC_SVR = 0x00F0
// Value = 0x1FF.
// Interrupt 256 i guess.
// bit 8 enables LAPIC and vector 0xFF is a safe spurious vector.
// Consider whether to set bit 12 (EOI broadcast suppression). 
// Default is broadcast; suppression is useful only 
// in specific setups (IRR/IRR bridging).
// 0x00F0 → the SVR register offset inside the LAPIC.
// 0x100  → bit 8 set → this enables the LAPIC.
// 0xFF   → the vector number (255) that the LAPIC will deliver 
//          if a spurious interrupt occurs.

// Important distinction
// This 0xFF vector is not part of the LVT entries.
// It’s the special vector defined in the SVR register.
// You must have an IDT entry at 0xFF, even if the handler 
// just acknowledges and returns, because the LAPIC may 
// deliver a spurious interrupt there.

    local_apic_write_command (
        (unsigned short) 0x00F0,  // // SVR register offset in LAPIC MMIO space
        (unsigned int) (  0x100 | LAPIC_SPURIOUS_VECTOR ) );  // Enable bit + vector

/*
//
// Global enable
    enableapic(
        cpu_get_apic_base() 
    );
*/

// Hardware enable the Local APIC if it wasn't enabled.
// Enable APIC by setting up the bit 11.
    cpu_set_apic_base( cpu_get_apic_base() );

/*
 // #debug
    printk("APIC Global enable 0x%x \n",
        getapicbase() );
*/

/*
    printk("Setup APIC Timer 0 ...\\\\\n");
    apic_timer(lapicbase);
*/
// see: apictim.c

// #todo #bugbug
// e o timer precisa mudar o vetor 
// pois 32 ja esta sendo usado pela redirection table.

    apic_timer();
}


/*
 # SIPI Sequence 
 
void APIC::wakeupSequence(U32 apicId, U8 pvect);
void APIC::wakeupSequence(U32 apicId, U8 pvect)
{
                ICRHigh hreg = {
				.destField = apicId
		};
 
		ICRLow lreg(DeliveryMode::INIT, Level::Deassert, TriggerMode::Edge);
 
		xAPICDriver::write(APIC_REGISTER_ICR_HIGH, hreg.value);
		xAPICDriver::write(APIC_REGISTER_ICR_LOW, lreg.value);
 
		lreg.vectorNo = pvect;
		lreg.delvMode = DeliveryMode::StartUp;
 
		Dbg("APBoot: Wakeup sequence following...");
 
		xAPICDriver::write(APIC_REGISTER_ICR_HIGH, hreg.value);
		xAPICDriver::write(APIC_REGISTER_ICR_LOW, lreg.value);
}
*/ 

// NOTE: ICRLow and ICRHigh are types in the Silcos kernel. If your code uses direct bit
// manipulations you must replace some code with bit operations.

void local_apic_send_init(unsigned int apic_id)
{
// Send one time.
// Respect the order: 
// First 0x310 then 0x300.

// High (0x310)
    local_apic_write_command(
        LAPIC_ICR_HIGH, 
        (apic_id << 24) );

// Low (0x300)
// (No vector? vector 0?)
    local_apic_write_command(
        LAPIC_ICR_LOW,
        ICR_INIT | 
        ICR_PHYSICAL | 
        ICR_ASSERT | 
        ICR_EDGE | 
        ICR_NO_SHORTHAND );

// Loop
    while ( local_apic_read_command(LAPIC_ICR_LOW) & ICR_SEND_PENDING )
    {
        asm volatile ("pause;");
    };
}


// ex: vector={0x08} =  address={0x8000}
void 
local_apic_send_startup(
    unsigned int apic_id, 
    unsigned int vector )
{
// Send one time.
// Respect the order: 
// First 0x310 then 0x300.

    //#todo
    //vector = (vector & 0xFF);

// High (0x310)
    local_apic_write_command(
        LAPIC_ICR_HIGH, 
        (apic_id << 24) );

// Low (0x300)
    local_apic_write_command(
        LAPIC_ICR_LOW,
        vector | 
        ICR_STARTUP | 
        ICR_PHYSICAL | 
        ICR_ASSERT | 
        ICR_EDGE | 
        ICR_NO_SHORTHAND );

// Loop
    while ( local_apic_read_command(LAPIC_ICR_LOW) & ICR_SEND_PENDING )
    {
        asm volatile ("pause;");
    }
}

// Send INIT IPI
void Send_INIT_IPI_Once(unsigned int apic_id)
{
// One single time.
    local_apic_write_command(0x280, 0);  // Clear APIC errors.
    local_apic_send_init(apic_id);
    mdelay(100); // wait 10 msec
}

// Send STARTUP IPI (twice)
// + What the function does
// + Loops twice, sending a STARTUP IPI to the target APIC ID.
// + Clears the Error Status Register (0x280) before each send.
// + Uses vector 0x08 → trampoline at 0x8000.
// + Waits 200 ms between sends.
void Send_STARTUP_IPI_Twice(unsigned int apic_id)
{
// Twice

    unsigned int vector_number = 0x8;
    long i=0;
    for (i=0; i<2; i++)
    {
        local_apic_write_command(0x280, 0);  // Clear APIC errors.
        local_apic_send_startup(apic_id, vector_number);
        mdelay(200); // wait 200 msec
    };
}

static void __apic_disable_legacy_pic(void)
{
// Legacy PIC mask all off.

    printk("apic_disable_legacy_pic:\n");

// Envia ICW1 reset
    out8(0x20,0x11);	// reset PIC 1
    out8(0xA0,0x11);	// reset PIC 2
// Envia ICW2 start novo PIC 1 e 2
    out8(0x21,0x20);	// PIC 1 localiza no IDT 39-32 
    out8(0xA1,0x28);	// PIC 2 localiza no IDT 47-40
// Envia ICW3
    out8(0x21,0x04);	// IRQ2 conexao em cascata com o PIC 2
    out8(0xA1,0x02);
// Envia ICW4
    out8(0x21,0x01);
    out8(0xA1,0x01);
// OCW1
// Desabilita todas as interrupcoes
    out8(0x21,0xFF);
    out8(0xA1,0xFF);
}

//
// End
//

