// Generated by Grok.
/*=====================================================================
 *  xxxEventLoopSystemEvents()
 *
 *  Minix-style server main loop:
 *      • Wait for a system message (RTLEventBuffer)
 *      • Validate the caller (TID)
 *      • Dispatch the event
 *      • Send a reply if the caller expects one
 *      • Throttle to ~60 fps (16 ms per round)
 *=====================================================================*/
static int xxxEventLoopSystemEvents(void)
{
    /* -----------------------------------------------------------------
     *  Constants – adjust to your kernel’s timer frequency
     * -----------------------------------------------------------------*/
    enum {
        JIFFIES_PER_SECOND = 1000,          /* rtl_jiffies() ticks per sec   */
        TARGET_MS_PER_FRAME = 16,           /* 60 fps                       */
        TARGET_JIFFIES = TARGET_MS_PER_FRAME * JIFFIES_PER_SECOND / 1000,
        MIN_SLEEP_MS   = 1,                 /* never sleep 0 ms             */
    };

    /* -----------------------------------------------------------------
     *  Local state
     * -----------------------------------------------------------------*/
    unsigned long start_jiffie = 0;
    unsigned long delta_jiffie = 0;
    int           need_reply   = FALSE;   /* set by xxxProcessEvent()    */

    /* -----------------------------------------------------------------
     *  Trusted caller list – only these TIDs may post events.
     *  In a real Minix system you would read this from a kernel table.
     * -----------------------------------------------------------------*/
    static const int trusted_tids[] = {
        TID_INIT,          /* Init process (PID 1)                     */
        TID_KERNEL,        /* Kernel thread that delivers IRQ events   */
        TID_FILESERVER,    /* FS server (if you allow cross-server calls) */
        /* add more … */
        -1                 /* terminator */
    };

    /* -----------------------------------------------------------------
     *  Helper: is the caller trusted?
     * -----------------------------------------------------------------*/
    static int is_trusted(int tid)
    {
        for (int i = 0; trusted_tids[i] != -1; ++i) {
            if (trusted_tids[i] == tid)
                return TRUE;
        }
        return FALSE;
    }

    /* -----------------------------------------------------------------
     *  MAIN LOOP
     * -----------------------------------------------------------------*/
    while (TRUE) {

        /* -------------------------------------------------------------
         *  1. Graceful shutdown
         * -------------------------------------------------------------*/
        if (isTimeToQuitServer)
            break;

        /* -------------------------------------------------------------
         *  2. Block until an event arrives.
         *     rtl_get_event() returns TRUE when RTLEventBuffer is filled.
         * -------------------------------------------------------------*/
        if (!rtl_get_event()) {
            /* Queue empty → put the thread in a wait-queue.
               rtl_wait_event() should wake us only when a new message
               is posted (implemented with a kernel semaphore/condition). */
            rtl_wait_event();
            continue;
        }

        /* -------------------------------------------------------------
         *  3. Extract caller TID (lower 16 bits of long[8])
         * -------------------------------------------------------------*/
        int caller_tid = (int)(RTLEventBuffer[8] & 0xFFFF);

        /* -------------------------------------------------------------
         *  4. Security check – drop messages from untrusted sources
         * -------------------------------------------------------------*/
        if (!is_trusted(caller_tid)) {
            /* Log + ignore.  In Minix you would send IPC_NOTIFY with
               ERROR(E_PERM) back to the caller. */
            debug_print("xxxServer: dropping msg from untrusted TID %d\n",
                        caller_tid);
            continue;
        }

        /* -------------------------------------------------------------
         *  5. Start timing the frame
         * -------------------------------------------------------------*/
        start_jiffie = rtl_jiffies();

        /* -------------------------------------------------------------
         *  6. Dispatch the message.
         *     xxxProcessEvent() fills a reply buffer if needed and
         *     sets *need_reply* accordingly.
         * -------------------------------------------------------------*/
        need_reply = FALSE;   /* reset for this round */

        xxxProcessEvent(
            (void *)RTLEventBuffer[0],   /* window / object pointer   */
            RTLEventBuffer[1],           /* message code              */
            RTLEventBuffer[2],           /* arg1                      */
            RTLEventBuffer[3],           /* arg2                      */
            caller_tid);

        /* -------------------------------------------------------------
         *  7. Send reply if the handler requested it
         * -------------------------------------------------------------*/
        if (need_reply)
            xxxSendResponse();

        /* -------------------------------------------------------------
         *  8. 60 fps throttling (optional but nice for UI servers)
         * -------------------------------------------------------------*/
        delta_jiffie = rtl_jiffies() - start_jiffie;

        if (delta_jiffie < TARGET_JIFFIES) {
            unsigned long sleep_ms =
                (TARGET_JIFFIES - delta_jiffie) * 1000 / JIFFIES_PER_SECOND;

            if (sleep_ms >= MIN_SLEEP_MS)
                rtl_sleep(sleep_ms);
        }

        /* -------------------------------------------------------------
         *  9. Yield to other threads (cooperative scheduling)
         * -------------------------------------------------------------*/
        rtl_yield();
    }

    /* -----------------------------------------------------------------
     *  Clean shutdown – notify Init that the server is gone.
     * -----------------------------------------------------------------*/
    xxxNotifyInitServerExit();
    return 0;
}
