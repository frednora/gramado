Design Notes for libgr_transform_to_screespace() and libgr_transform_from_viewspace_to_screespace() 
functions generated by Copilot.

Hereâ€™s a detailed explanation and step-by-step documentation for both functions you mentioned, 
based on your implementation 
in [libgr.c](https://github.com/frednora/gramado/blob/main/outside/gram3d/libs/libgr/libgr.c). 
This documentation should help you and others understand and maintain these projection-related functions.

---

## 1. `libgr_transform_to_screespace`

**Purpose:**  
Transforms a 2D coordinate from the "view space" to "screen space," 
considering a screen center (hotspot) as the origin.

**Signature:**
```c
int libgr_transform_to_screespace(
    int *res_x, int *res_y,
    int _x, int _y, 
    int _hotspotx, int _hotspoty )
```

**Step-by-step documentation:**
1. **Parameter Handling**  
   - `res_x`, `res_y`: Output pointers for screen-space coordinates.
   - `_x`, `_y`: Input coordinates in view space.
   - `_hotspotx`, `_hotspoty`: The center of the screen in screen coordinates.

2. **Convert Inputs**  
   ```c
   int x  = (int) _x;
   int y  = (int) _y;
   int hotspotx = (int) (_hotspotx & 0xFFFFFFFF);
   int hotspoty = (int) (_hotspoty & 0xFFFFFFFF);
   ```

3. **Transform the X Coordinate**  
   - If `x >= 0`: Move right from the hotspot.
   - If `x < 0`: Move left from the hotspot.
   ```c
   if (x >= 0 ){
       X = (int) ( hotspotx + x );
   }
   if (x < 0 ){
       x = abs(x);
       X = (int) ( hotspotx - x );
   }
   ```

4. **Transform the Y Coordinate**  
   - If `y >= 0`: Move up from the hotspot (screen Y axis usually grows downward).
   - If `y < 0`: Move down from the hotspot.
   ```c
   if (y >= 0){
       Y = (int) ( hotspoty - y );
   }
   if (y < 0){
       y = abs(y);
       Y = (int) ( hotspoty + y );
   }
   ```

5. **Write Back the Result**  
   - Store calculated values in `*res_x` and `*res_y` if output is valid.
   - Returns 0 on success, -1 on failure (null pointers).

**Summary:**  
This function maps a point (x, y) from a centered coordinate system to the regular screen coordinates, with a chosen origin (hotspot).

---

## 2. `libgr_transform_from_viewspace_to_screespace`

**Purpose:**  
Projects a 3D point `(x, y, z)` in "view space" to a 2D screen-space coordinate `(res_x, res_y)` using a simple hand-made oblique projection, with optional left-hand or right-hand rules.

**Signature:**
```c
int libgr_transform_from_viewspace_to_screespace(
    int *res_x, int *res_y,
    int _x, int _y, int _z,
    int left_hand,
    int _hotspotx, int _hotspoty )
```

**Step-by-step documentation:**
1. **Parameter Handling**  
   - `res_x`, `res_y`: Output pointers.
   - `_x`, `_y`, `_z`: Input 3D coordinates (view space).
   - `left_hand`: Use left-hand (`TRUE`) or right-hand (`FALSE`) coordinate system.
   - `_hotspotx`, `_hotspoty`: The screen center.

2. **Convert Inputs**  
   ```c
   int x  = (int) _x;
   int y  = (int) _y;
   int z  = (int) _z;
   int hotspotx = (int) (_hotspotx & 0xFFFFFFFF);
   int hotspoty = (int) (_hotspoty & 0xFFFFFFFF);
   ```

3. **Project X (2D X calculation)**  
   - If `z >= 0`:  
     - If `x >= 0`: `X = hotspotx + x`
     - If `x < 0`:  `X = hotspotx - abs(x)`
   - If `z < 0`:  
     - If `x >= 0`: `X = hotspotx + x`
     - If `x < 0`:  `X = hotspotx - abs(x)`

4. **Project Y (2D Y calculation)**  
   - If `y >= 0`: `Y = hotspoty - y`
   - If `y < 0`:  `Y = hotspoty + abs(y)`

5. **Adjust for Z using the chosen coordinate system**  
   - **Left-hand system:**
     - If `z >= 0`: Move right and up by `z`:  
       `X = X + z`, `Y = Y - z`
     - If `z < 0`: Move left and down by `|z|`:  
       `X = X - |z|`, `Y = Y + |z|`
   - **Right-hand system:**
     - If `z >= 0`: Move left and down by `z`:  
       `X = X - z`, `Y = Y + z`
     - If `z < 0`: Move right and up by `|z|`:  
       `X = X + |z|`, `Y = Y - |z|`

6. **Write Back the Result**  
   - Store calculated values in `*res_x` and `*res_y` if output is valid.
   - Returns 0 on success, -1 on failure (null pointers).

**Summary:**  
This function implements a Cavalier Oblique projection (simple 3D-to-2D), which is easy to visualize and code. The `z` component is mapped to both X and Y for the oblique effect, and the handedness parameter (`left_hand`) controls the projection style.

---

## References

- [libgr_transform_to_screespace in source](https://github.com/frednora/gramado/blob/main/outside/gram3d/libs/libgr/libgr.c#L10)
- [libgr_transform_from_viewspace_to_screespace in source](https://github.com/frednora/gramado/blob/main/outside/gram3d/libs/libgr/libgr.c#L128)

---

**If you want improvements, such as a true perspective matrix or normalized device coordinates, let me know!**  
For more details or other results, see the [libgr.c on GitHub](https://github.com/frednora/gramado/blob/main/outside/gram3d/libs/libgr/libgr.c).